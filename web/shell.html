<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gravitium War (Web)</title>
  <style>
    :root {
      --game-aspect: 8 / 5;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    #canvas {
      position: fixed;
      left: 0;
      top: 0;
      width: 0;
      height: 0;
      display: block;
      outline: none;
      background: #000;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #loading {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      z-index: 1;
    }

    #loading.hidden {
      display: none;
    }

    .spinner {
      width: 36px;
      height: 36px;
      border: 3px solid #2f2f2f;
      border-top-color: #ffffff;
      border-radius: 999px;
      animation: spin 0.8s linear infinite;
    }

    .loading-text {
      font-size: 13px;
      letter-spacing: 0.04em;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="loading" role="status" aria-live="polite">
    <div class="spinner" aria-hidden="true"></div>
    <div id="loading-text" class="loading-text">Downloading...</div>
  </div>

  <canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>

  <script>
    const canvasElement = document.getElementById("canvas");
    const loadingElement = document.getElementById("loading");
    const loadingTextElement = document.getElementById("loading-text");
    const GAME_ASPECT = 320 / 200;

    let canvasFitFrame = 0;
    function fitCanvas() {
      const viewport = window.visualViewport;
      const viewportWidth = Math.max(1, Math.floor(viewport ? viewport.width : window.innerWidth));
      const viewportHeight = Math.max(1, Math.floor(viewport ? viewport.height : window.innerHeight));
      const targetWidth = viewportWidth;
      const targetHeight = Math.round(targetWidth / GAME_ASPECT);
      const offsetY = Math.floor((viewportHeight - targetHeight) / 2);

      canvasElement.style.width = `${targetWidth}px`;
      canvasElement.style.height = `${targetHeight}px`;
      canvasElement.style.left = "0px";
      canvasElement.style.top = `${offsetY}px`;
    }

    function scheduleCanvasFit() {
      if (canvasFitFrame) return;
      canvasFitFrame = window.requestAnimationFrame(() => {
        canvasFitFrame = 0;
        fitCanvas();
      });
    }

    function showLoading(text) {
      if (loadingTextElement && text) loadingTextElement.textContent = text;
      if (loadingElement) loadingElement.classList.remove("hidden");
    }

    function hideLoading() {
      if (loadingElement) loadingElement.classList.add("hidden");
    }

    function normalizeStatusText(text) {
      const m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
      if (!m) return text;
      return `${m[1].trim()} ${m[2]}/${m[4]}`;
    }

    const urlParams = new URLSearchParams(window.location.search);
    const moduleArguments = [];
    for (const arg of urlParams.getAll("arg")) {
      if (arg) moduleArguments.push(arg);
    }

    var Module = {
      preRun: [],
      postRun: [],
      arguments: moduleArguments,
      canvas: canvasElement,
      print: (...args) => console.log(args.join(" ")),
      printErr: (...args) => console.log("[stderr] " + args.join(" ")),
      setStatus: function(text) {
        if (!text) {
          hideLoading();
          return;
        }
        showLoading(normalizeStatusText(text));
      },
      monitorRunDependencies: function(left) {
        const done = this.totalDependencies ? (this.totalDependencies - left) : 0;
        this.totalDependencies = Math.max(this.totalDependencies || 0, left);
        this.setStatus(left ? `Preparing... (${done}/${this.totalDependencies})` : "");
      },
      onAbort: function(reason) {
        console.log("[abort] " + reason);
      }
    };

    window.onerror = function(message, source, line, col, error) {
      console.log(`[window.onerror] ${message} @ ${source || "unknown"}:${line || 0}:${col || 0}`);
      if (error && error.stack) console.log(error.stack);
      return false;
    };

    window.onunhandledrejection = function(event) {
      const reason = event && event.reason;
      console.log("[unhandledrejection] " + ((reason && (reason.stack || reason.message)) || String(reason)));
    };

    window.addEventListener("resize", scheduleCanvasFit, { passive: true });
    window.addEventListener("orientationchange", scheduleCanvasFit, { passive: true });
    if (window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(scheduleCanvasFit);
      resizeObserver.observe(canvasElement);
    }
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", scheduleCanvasFit, { passive: true });
      window.visualViewport.addEventListener("scroll", scheduleCanvasFit, { passive: true });
    }

    scheduleCanvasFit();
    showLoading("Downloading...");
  </script>

  {{{ SCRIPT }}}
</body>
</html>
